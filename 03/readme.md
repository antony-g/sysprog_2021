# Домашнее задание №2 
## Файловая система

### Задание
Нужно реализовать свою файловую систему в памяти. Не пугайтесь,
это не сложно. Для старта предоставляется шаблон интерфейса с
некоторыми уже реализованными структурами, в файлах __userfs.h__ и
__userfs.c__.

Файловая система называется __UserFS__, и очень примитивна. В ней нет
папок - все файлы лежат в "руте". Файлы можно создавать, удалять,
открывать на них дескрипторы и закрывать их. Каждый файл похож по
структуре на файловую систему __FAT__: это список блоков. В __userfs.c__
можно посмотреть структуры, которые описывают блок и файл, где
лежит их список. Блоки фиксированного размера, размер файла
ограничен.

На диске не хранится ничего - все в оперативной памяти, на куче.
Файлы можно читать/писать по дескриптору. API похоже на реальное
из __libc__:

```C
int
ufs_open(const char *filename, int flags);

ssize_t
ufs_write(int fd, const char *buf, size_t size);

ssize_t
ufs_read(int fd, char *buf, size_t size);

int
ufs_close(int fd);

int
ufs_delete(const char *filename);
```

Прочитать описания этих функций можно в __userfs.h__.

### Примеры
Ваша основная задача - реализовать увеличение файла по мере записи
в него, и реализовать файловый дескриптор. Рассмотрим пару
примеров.

Есть код:

```C
        int fd = ufs_open("any_file_name", UFS_CREATE);
```

После этой строки внутри userfs.c создается struct file с именем
"any_file_name", если его еще нет. Затем создается файловый
дескриптор struct filedesc.

```C
        const char *data = "bla bla bla";
        ufs_write(fd, data, strlen(data));
```

Файл пустой, в нем нет блоков, поэтому вам нужно аллоцировать
нужное число блоков `struct block`. В данном случае это 1. В него
копируем данные. Ваш файл начинает выглядеть так:

```C
        file:
        +---------------------+
        | bla bla bla|        | -> NULL.
        +---------------------+
                     ^
                  filedesc - дескриптор указывает сюда. Например,
                             в дескрипторе вы можете хранить
                             номер блока и смещение в нем.
```

Затем я продолжаю писать, но уже больше данных:

```C
        char buf[1024];
        memset(buf, 0, sizeof(buf));
        ufs_write(fd, buf, sizeof(buf));

```

Вот что получится:

```C
        file:
        +---------------------+    +---------------------+
        | bla bla bla 0 0 0 0 | -> | 0 0 0 0 0 0 0 0 0 0 | ->
        +---------------------+    +---------------------+

        +---------------------+
     -> | 0 0 0 0 0 0|        | -> NULL.
        +---------------------+
                     ^
                  filedesc
```

То есть понадобилось дозаполнить уже имеющийся блок, и создать еще
два блока. Они просто добавились в конец списка.

Тоже самое с чтениями - дескриптор читает последовательно
перепрыгивая на следующий блок, когда дочитал предыдущий.

Поскольку задача - реализация библиотеки, то программы __main__ нет,
а значит и принимать на вход некуда. Вы можете писать тесты на С,
в отдельном файле, где будет __main__, и куда будет делаться __include__
вашего решения. Например, создается файл __main.c__, который делает
`include "userfs.h"` и в функции __main__ делает какие-то тесты.
Это все собирается так:

```
        gcc userfs.c main.c
```

### Реализация

- 15 баллов: реализовать все функции из userfs.c, как описано
  выше.

- +5 баллов: реализовать режимы открытия файла: на чтение, на
  запись, на чтение-запись. Когда файл открывается, дескриптор в
  себе хранит режим. Когда зовется функция read/write, то режим
  проверяется. Вот и все. Флаги должны быть названы UFS_READ_ONLY,
  UFS_WRITE_ONLY, UFS_READ_WRITE. По умолчанию файл должен
  открываться на UFS_READ_WRITE. В случае ошибки доступа должна
  выставляться ошибка UFS_ERR_NO_PERMISSION.

- +5 баллов: реализовать resize. Появляется функция

```C
        int ufs_resize(int fd, size_t new_size);
```

  Она увеличивет или уменьшает размер файла. Если файл
  уменьшается, и часть файловых дескрипторов начинает указывать за
  пределы размера файла, то они сдвигаются на его новый конец.

Добавочные пункты на +5 баллов друг друга не включают. То есть
можно не делать ни одного, можно сделать первый, или второй, или
оба для +10.
